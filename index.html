<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSV Quizzer</title>
  <style>
    body { font-family: sans-serif; background: #f9fafb; color: #111; margin: 0; padding: 20px; }
    .container { max-width: min(1280px, 95vw); margin: auto; }
    .panel { margin-bottom: 20px; padding: 20px; background: #fff; border: 1px solid #ddd; border-radius: 8px; }
    .card { padding: 20px; background: #fff; border: 1px solid #ddd; border-radius: 8px; margin-top: 10px; }
    .q { font-size: 20px; margin-bottom: 10px; }
    .feedback { font-weight: bold; margin-top: 10px; }
    .good { color: green; }
    .bad { color: red; }
    .superfluous { color: blue; }
    .stats { margin-top: 10px; color: #555; }
    input[type="text"] { padding: 8px; width: calc(100% - 100px); margin-right: 10px; border: 1px solid #ccc; border-radius: 4px; }
    button { padding: 8px 12px; border-radius: 4px; border: 1px solid #ccc; background-color: #f0f0f0; cursor: pointer; }
    button:hover { background-color: #e0e0e0; }
    .empty-msg { margin-top: 15px; font-size: 16px; color: #333; }
    .summary { margin-top: 15px; font-size: 14px; color: #333; }
    .summary ul { padding-left: 20px; }
    .summary .summary-mono { white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#f6f8fa; border:1px solid #eee; border-radius:6px; padding:12px; max-width: 100%; overflow-x: auto; overflow-y: hidden; font-size: 13px; }
    .hint { margin-top: 8px; color: #666; font-size: 12px; }
    kbd { background: #eee; border: 1px solid #ccc; border-radius: 3px; padding: 1px 4px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .category-filters { margin-top: 10px; display: flex; flex-wrap: wrap; gap: 10px; }
    .category-filters label { display: inline-flex; align-items: center; cursor: pointer; }
    .category-filters input[type="checkbox"] { margin-right: 5px; }
    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: #f4f4f4;
      padding: 2px 4px;
      border-radius: 4px;
      color: maroon;
    }
    pre code {
      display: block;
      white-space: pre;
      padding: 12px;
      overflow-x: auto;
    }
  @media (min-width: 1200px) { .summary .summary-mono { overflow: hidden; } }

  .csv-editor-table { width: 100%; border-collapse: collapse; }
  .csv-editor-table th, .csv-editor-table td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: top; }
  .csv-editor-table th { background-color: #f2f2f2; }
  .csv-editor-table textarea, .csv-editor-table input {
    width: 100%;
    min-width: 100px;
    padding: 4px;
    border: 1px solid #ccc;
    box-sizing: border-box;
    resize: vertical;
    border-radius: 4px;
  }
  .csv-editor-table textarea {
    min-height: 100px;
    overflow: hidden;
  }
  .csv-editor-table .cell-priority { width: 50px; }
  .edit-button-red { background-color: #f44336; color: white; border-color: #f44336; }
  .edit-button-red:hover { background-color: #d32f2f; }
  .edit-fields { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
  .start-btn-green { background-color: #4CAF50; color: white; border: none; }
  .start-btn-green:hover { background-color: #45a049; }
  .start-btn-green:disabled { background-color: #a5d6a7; cursor: not-allowed; }
  .csv-editor-table .question-preview,
  #editFields .question-preview {
    max-height: 100px;
    overflow-y: auto;
    padding: 8px;
    border: 1px solid #ccc;
    background-color: #f9f9f9;
    border-radius: 4px;
  }
  .priority-controls { display: flex; align-items: center; }
  .priority-controls input { width: 50px; text-align: center; margin: 0 5px; }
  .priority-controls button {
    width: 25px;
    height: 25px;
    padding: 0;
    line-height: 1;
    font-size: 18px;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
</head>
<body>
  <div class="container">
    <div id="main-panel" class="panel">
      <input id="file" type="file" accept=".csv,text/csv" />
      <button id="editCsvBtn" style="display:none">Edit CSV</button>
      <div id="meta">No file loaded.</div>

      <div style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px;">
        <div style="display: flex; flex-wrap: wrap; gap: 20px; align-items: flex-end;">
            <div>
                <label for="startBtn" style="display: block; margin-bottom: 5px;"><strong>Standard Quiz</strong> (uses category filters)</label>
                <button id="startBtn" class="start-btn-green" disabled>Start Standard Quiz</button>
            </div>
            <div>
                <label for="numCards" style="display: block; margin-bottom: 5px;"><strong>Priority Quiz</strong> (top N cards)</label>
                <input type="number" id="numCards" value="25" min="1" style="width: 70px; padding: 8px; vertical-align: middle; border: 1px solid #ccc; border-radius: 4px;">
                <button id="priorityQuizBtn" class="start-btn-green" disabled>Start Priority Quiz</button>
            </div>
        </div>
      </div>
    </div>
    
    <div id="category-panel" class="panel" style="display:none">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h4>Filter by Category</h4>
            <div>
                <button id="toggle-all-btn">Toggle All</button>
                <button id="toggle-none-btn">Toggle None</button>
            </div>
        </div>
        <div id="category-filters" class="category-filters"></div>
    </div>

    <div id="quiz-panel" class="card" style="display:none">
      <div class="q" id="question"></div>
      <input id="answer" type="text" placeholder="Type the answer…" />
      <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
        <div>
          <button id="submitBtn">Check</button>
          <button id="skipBtn">Skip</button>
        </div>
        <div>
          <button id="editQuestionBtn" class="edit-button-red">Edit Question</button>
        </div>
      </div>
      <div class="edit-fields" id="editFields" style="display:none">
        <label>
          Question:
          <textarea id="editQuestion" rows="3"></textarea>
        </label>
        <div class="question-preview" id="editQuestionPreview"></div>
        <label>
          Answer:
          <textarea id="editAnswer" rows="2"></textarea>
        </label>
        <div style="display: flex; gap: 10px;">
          <button id="updateCardBtn">Update</button>
          <button id="cancelEditBtnQuiz">Cancel</button>
        </div>
      </div>
      <div class="feedback" id="feedback"></div>
      <div id="end-quiz-confirm" style="display:none; color: #d97706; font-weight: bold; margin-top: 10px;"></div>
      <div class="hint">Hotkeys: <kbd>Enter</kbd> to check • <kbd>Ctrl</kbd> + <kbd>Enter</kbd> to skip • <kbd>Shift</kbd> + <kbd>Enter</kbd> to end &amp; summary</div>
      <div class="empty-msg" id="emptyMsg" style="display:none"></div>
    <div class="summary" id="summary" style="display:none"></div>
    </div>

    <div id="editor-panel" class="panel" style="display:none">
      <h4>Edit Flashcards</h4>
      <div id="editorTable"></div>
      <div style="margin-top: 15px; display: flex; gap: 10px;">
        <button id="addCardBtn">Add New Card</button>
        <button id="sortCategoryBtn">Sort by Category</button>
        <button id="saveAndDownloadBtn">Save & Download</button>
        <button id="cancelEditBtn">Save & Back to Main</button>
      </div>
    </div>

    <div class="stats" id="stats">Loaded: 0 • Correct: 0 • Attempts: 0 • Streak: 0</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
  <script>
    // Robust CSV parser that supports quoted fields and commas inside quotes
    function parseCSV(text) {
      const rows = [];
      let row = [];
      let field = '';
      let i = 0;
      let inQuotes = false;
      while (i < text.length) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            const next = text[i + 1];
            if (next === '"') { field += '"'; i += 2; continue; } // escaped quote
            inQuotes = false; i++; continue;
          } else {
            field += c; i++; continue;
          }
        } else {
          if (c === '"') { inQuotes = true; i++; continue; }
          if (c === ',') { row.push(field); field = ''; i++; continue; }
          if (c === '\n') { row.push(field); rows.push(row); row = []; field = ''; i++; continue; }
          if (c === '\r') { if (text[i + 1] === '\n') { i += 2; } else { i++; } row.push(field); rows.push(row); row = []; field = ''; continue; }
          field += c; i++;
        }
      }
      row.push(field);
      if (!(row.length === 1 && row[0] === '' && rows.length > 0)) rows.push(row);
      return rows;
    }

    const $ = (id) => document.getElementById(id);
    const fileInput = $('file');
    const startBtn = $('startBtn');
    const editCsvBtn = $('editCsvBtn');
    const meta = $('meta');
    const mainPanel = $('main-panel');
    const categoryPanel = $('category-panel');
    const categoryFiltersEl = $('category-filters');
    const toggleAllBtn = $('toggle-all-btn');
    const toggleNoneBtn = $('toggle-none-btn');
    const numCardsInput = $('numCards');
    const priorityQuizBtn = $('priorityQuizBtn');
    
    const quizPanel = $('quiz-panel');
    const questionEl = $('question');
    const answerEl = $('answer');
    const feedbackEl = $('feedback');
    const endQuizConfirmEl = $('end-quiz-confirm');
    const submitBtn = $('submitBtn');
    const skipBtn = $('skipBtn');
    const editQuestionBtn = $('editQuestionBtn');
    const editFields = $('editFields');
    const editQuestionEl = $('editQuestion');
    const editQuestionPreview = $('editQuestionPreview');
    const editAnswerEl = $('editAnswer');
    const updateCardBtn = $('updateCardBtn');
    const cancelEditBtnQuiz = $('cancelEditBtnQuiz');
    
    const editorPanel = $('editor-panel');
    const editorTable = $('editorTable');
    const addCardBtn = $('addCardBtn');
    const sortCategoryBtn = $('sortCategoryBtn');
    const saveAndDownloadBtn = $('saveAndDownloadBtn');
    const cancelEditBtn = $('cancelEditBtn');

    const statsEl = $('stats');
    const emptyMsg = $('emptyMsg');
    const summaryEl = $('summary');

    let cards = [];
    let current = null;
    let unused = [];
    let fileName = 'updated_quiz_deck.csv';
    let isPaused = false;
    let endQuizConfirmation = false;

    let incorrectLog = [];
    let lastRoundMistakeIds = [];
    let allCategories = new Set();
    let activeCategories = new Set();

    const state = { correct: 0, attempts: 0, streak: 0 };
    let roundCorrect = 0;
    let roundAttempts = 0;

    function showPanel(panelToShow) {
        const panels = [mainPanel, categoryPanel, quizPanel, editorPanel];
        panels.forEach(panel => {
            if (panel.id === panelToShow.id) {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        });
    }

    function updateStats() {
      statsEl.textContent = `Loaded: ${cards.length} • Available: ${unused.length} • Correct: ${state.correct} • Attempts: ${state.attempts} • Streak: ${state.streak}`;
    }

    // Case-sensitive; ignore ALL whitespace differences (spaces, tabs, newlines)
    function normalizeForCompare(s) {
      /* Example: "a | b" === "a|b" === "a\n|\tb" */
      return s.replace(/\s+/g, '');
    }

    // Pick a card based on its priority using an exponential distribution
    function pickNextCard() {
      if (!unused.length) return null;

      // Calculate the total priority of all available cards
      const totalPriority = unused.reduce((sum, card) => sum + card.priority, 0);

      // Generate a random number between 0 and the total priority
      let rand = Math.random() * totalPriority;

      // Find the card to be selected
      for (let i = 0; i < unused.length; i++) {
        rand -= unused[i].priority;
        if (rand <= 0) {
          const card = unused[i];
          unused.splice(i, 1);
          return card;
        }
      }
      
      // Fallback in case of rounding errors, pick the last card
      const card = unused.pop();
      return card;
    }

    function showCard(card) {
      current = card;
      if (!card) return;

      questionEl.innerHTML = marked.parse(card.q);
      if (typeof renderMathInElement !== 'undefined') {
        renderMathInElement(questionEl, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
          ]
        });
      }

      answerEl.value = '';
      feedbackEl.textContent = '';
    }

    function downloadCSV(cardsToDownload) {
      const csvRows = cardsToDownload.map(card => {
        const q = `"${String(card.q).replace(/"/g, '""')}"`;
        const a = `"${String(card.a).replace(/"/g, '""')}"`;
        const category = `"${String(card.category).replace(/"/g, '""')}"`;
        const priority = card.priority;
        return [q, a, category, priority].join(',');
      });

      const csvContent = csvRows.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement("a");
      const url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", fileName);
      link.style.display = "none";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function showSummary() {
      if (!summaryEl) return;
      function esc(s){ return String(s).replace(/[&<>"]/g, function(ch){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[ch]); }); }
      let html = `<strong>Deck complete!</strong><br/>`;
      html += `Round Score: ${roundCorrect} / ${roundAttempts}<br/>`;
      html += `Cumulative Score: ${state.correct} / ${state.attempts}<br/>`;

      if (incorrectLog.length) {
        const rows = incorrectLog.map(item => ({ q: item.q, given: item.given, a: item.a }));
        const leftPlain = rows.map(r => `Your answer: ${r.given}`);
        const maxLeft = leftPlain.reduce((m, s) => Math.max(m, s.length), 0);
        const lines = rows.map((r, i) => {
          const plain = leftPlain[i];
          const pad = ' '.repeat(Math.max(0, maxLeft - plain.length));
          const leftHtml = `<span class="bad">Your answer:</span> ${esc(r.given)}`;
          const rightHtml = `<span class="good">Correct:</span> ${esc(r.a)}`;
          return `${leftHtml}${pad} | ${rightHtml} — <em>${esc(r.q)}</em>`;
        });
        html += `<p>Incorrect answers:</p><pre class="summary-mono">${lines.join('\n')}</pre>`;
      }
      html += `<button id="downloadMistakesBtn">Download Updated CSV</button>`;
      summaryEl.innerHTML = html;
      summaryEl.style.display = '';
      document.getElementById('downloadMistakesBtn').onclick = () => {
        downloadCSV(cards);
      };
    }

    function endOfRound() {
      const idSet = new Set(incorrectLog.map(x => x.id));
      lastRoundMistakeIds = Array.from(idSet);
      if (summaryEl) showSummary();
      if (emptyMsg) emptyMsg.style.display = '';
      const hasMistakes = lastRoundMistakeIds.length > 0;
      if (emptyMsg) emptyMsg.innerHTML = `Deck exhausted. <button id="cycleBtn">Cycle Again?</button> ${hasMistakes ? '<button id="mistakesBtn">Review Mistakes</button>' : ''}`;

      const cycleBtn = document.getElementById('cycleBtn');
      if (cycleBtn) {
        cycleBtn.onclick = () => {
          roundCorrect = 0;
          roundAttempts = 0;
          prepareDeck();
          incorrectLog = [];
          if (summaryEl) summaryEl.style.display = 'none';
          if (emptyMsg) emptyMsg.style.display = 'none';
          nextCard();
        };
      }

      const mistakesBtn = document.getElementById('mistakesBtn');
      if (hasMistakes && mistakesBtn) {
        mistakesBtn.onclick = () => {
          const mistakeSet = new Set(lastRoundMistakeIds);
          const mistakeDeck = cards.filter(c => mistakeSet.has(c.id));
          unused = [...mistakeDeck];
          incorrectLog = [];
          if (summaryEl) summaryEl.style.display = 'none';
          if (emptyMsg) emptyMsg.style.display = 'none';
          nextCard();
        };
      }
    }

    function resetEndConfirmation() {
        if (endQuizConfirmation) {
            endQuizConfirmation = false;
            endQuizConfirmEl.style.display = 'none';
        }
    }

    function nextCard() {
      resetEndConfirmation();
      if (isPaused) return; 
      if (!unused.length) {
        if (questionEl) questionEl.textContent = '';
        if (feedbackEl) feedbackEl.textContent = '';
        endOfRound();
        return;
      }
      if (emptyMsg) emptyMsg.style.display = 'none';
      if (summaryEl) summaryEl.style.display = 'none';
      showCard(pickNextCard());
      updateStats();
    }

    function diffChars(a, b) { // a = user, b = correct
      const matrix = Array(a.length + 1).fill(0).map(() => Array(b.length + 1).fill(0));

      for (let i = 1; i <= a.length; i++) {
          for (let j = 1; j <= b.length; j++) {
              if (a[i - 1] === b[j - 1]) {
                  matrix[i][j] = matrix[i - 1][j - 1] + 1;
              } else {
                  matrix[i][j] = Math.max(matrix[i - 1][j], matrix[i][j - 1]);
              }
          }
      }

      let i = a.length;
      let j = b.length;
      const result = [];
      
      while (i > 0 || j > 0) {
          if (i > 0 && j > 0 && a[i - 1] === b[j - 1]) {
              result.unshift({ value: a[i - 1], type: 'common' });
              i--;
              j--;
          } else if (j > 0 && (i === 0 || matrix[i][j - 1] >= matrix[i - 1][j])) {
              result.unshift({ value: b[j - 1], type: 'added' }); // In correct, not user
              j--;
          } else if (i > 0 && (j === 0 || matrix[i][j - 1] < matrix[i - 1][j])) {
              result.unshift({ value: a[i - 1], type: 'removed' }); // In user, not correct
              i--;
          } else {
              break;
          }
      }
      return result;
    }

    function onSubmit() {
      resetEndConfirmation();
      if (!current || isPaused) return; 
      const user = answerEl.value;
      const ok = normalizeForCompare(user) === normalizeForCompare(current.a);
      state.attempts++;
      roundAttempts++;
      if (ok) {
        state.correct++; state.streak++;
        roundCorrect++;
        feedbackEl.textContent = 'Correct!';
        feedbackEl.className = 'feedback good';
        // Decrease priority for correct answers
        current.priority = Math.max(1, current.priority - 1);
        nextCard(); // Move to the next card immediately
      } else {
        isPaused = true;
        answerEl.disabled = true;
        submitBtn.disabled = true;
        skipBtn.disabled = true;

        state.streak = 0;
        
        const diffResult = diffChars(user, current.a);
        const hasAdded = diffResult.some(part => part.type === 'added');
        const hasRemoved = diffResult.some(part => part.type === 'removed');

        let feedbackPrefix;
        let diffHtml;

        if (hasRemoved && !hasAdded) {
            // Superset case: user's answer contains the correct answer plus extra characters.
            feedbackPrefix = "Incorrect. Your answer had extra characters: ";
            diffHtml = diffResult.map(part => {
                const value = part.value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                if (part.type === 'common') {
                    return `<span>${value}</span>`;
                } else { // 'removed'
                    return `<span class="superfluous" style="text-decoration: underline;">${value}</span>`;
                }
            }).join('');
        } else {
            // Subset or mixed diff case: show the expected answer with missing parts.
            feedbackPrefix = "Incorrect. Expected: ";
            diffHtml = diffResult.map(part => {
                const value = part.value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                if (part.type === 'common') {
                    return `<span>${value}</span>`;
                } else if (part.type === 'added') {
                    return `<span class="bad" style="text-decoration: underline;">${value}</span>`;
                }
                return ''; // Ignore 'removed' parts for this view
            }).join('');
        }
        
        feedbackEl.innerHTML = feedbackPrefix + diffHtml;
        feedbackEl.className = 'feedback';

        // Increase priority for incorrect answers
        current.priority = Math.min(1024, current.priority * 2);
        incorrectLog.push({ id: current.id, q: current.q, a: current.a, given: user });
        
        setTimeout(() => {
            isPaused = false;
            answerEl.disabled = false;
            submitBtn.disabled = false;
            skipBtn.disabled = false;
            nextCard();
            answerEl.focus();
        }, 4000); // Wait 4 seconds before moving on
      }
      updateStats();
    }
    
    function prepareDeck() {
      unused = cards.filter(card => activeCategories.has(card.category));
      startBtn.disabled = unused.length === 0;
      updateStats();
    }

    function renderCategoryFilters() {
      categoryFiltersEl.innerHTML = '';
      if (allCategories.size === 0) {
        categoryPanel.style.display = 'none';
        return;
      }
      categoryPanel.style.display = 'block';
      allCategories.forEach(category => {
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.dataset.category = category;
        
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            activeCategories.add(e.target.dataset.category);
          } else {
            activeCategories.delete(e.target.dataset.category);
          }
          prepareDeck();
        });

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(category));
        categoryFiltersEl.appendChild(label);
      });
      prepareDeck();
    }
    
    function toggleAll() {
      document.querySelectorAll('#category-filters input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = true;
      });
      activeCategories = new Set(allCategories);
      prepareDeck();
    }

    function toggleNone() {
      document.querySelectorAll('#category-filters input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
      activeCategories.clear();
      prepareDeck();
    }

    function loadFromText(text, name='file') {
      fileName = name;
      const rows = parseCSV(text);
      // Check for header row and skip it
      const hasHeader = rows[0] && ['question', 'answer', 'category', 'priority'].includes(rows[0][0]?.toLowerCase().trim().replace(/"/g, ''));
      const dataRows = hasHeader ? rows.slice(1) : rows;

      cards = dataRows.map((r, idx) => ({ 
        id: idx, 
        q: String(r[0] || '').trim(), 
        a: String(r[1] || '').trim(), 
        category: r[2] ? String(r[2]).trim() : 'Uncategorized', 
        priority: (r[3] && !isNaN(parseFloat(r[3]))) ? parseFloat(r[3]) : 1 
      })).filter(x => x.q && x.a);
      
      allCategories.clear();
      cards.forEach(card => allCategories.add(card.category));
      activeCategories = new Set(allCategories);

      incorrectLog = [];
      lastRoundMistakeIds = [];
      meta.textContent = cards.length ? `Loaded ${cards.length} cards from ${name}` : 'No valid rows found.';
      editCsvBtn.style.display = cards.length > 0 ? 'inline' : 'none';
      priorityQuizBtn.disabled = cards.length === 0;
      
      roundCorrect = 0;
      roundAttempts = 0;

      renderCategoryFilters();
      prepareDeck();
    }
    
    function getEditedCardsFromTable() {
      const updatedCards = [];
      const rows = document.querySelectorAll('#editorTable table tbody tr');
      rows.forEach((row, index) => {
          const inputs = row.querySelectorAll('textarea, input');
          const id = row.dataset.id ? parseInt(row.dataset.id, 10) : (cards[index] ? cards[index].id : index);
          const updatedCard = {
              id: id,
              q: inputs[0].value,
              a: inputs[1].value,
              category: inputs[2].value,
              priority: Math.max(1, parseFloat(inputs[3].value) || 1)
          };
          updatedCards.push(updatedCard);
      });
      return updatedCards;
    }

    function autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
    }

    function renderEditorTable() {
      const table = document.createElement('table');
      table.className = 'csv-editor-table';
      
      const header = table.createTHead().insertRow();
      ['Question', 'Preview', 'Answer', 'Category', 'Priority', 'Actions'].forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        header.appendChild(th);
      });

      const tbody = table.createTBody();
      cards.forEach((card, index) => {
        const row = tbody.insertRow();
        row.dataset.id = card.id;
        
        const questionCell = row.insertCell();
        const questionInput = document.createElement('textarea');
        questionInput.value = card.q;
        questionInput.addEventListener('input', () => autoResizeTextarea(questionInput));
        questionCell.appendChild(questionInput);
        
        const previewCell = row.insertCell();
        const previewDiv = document.createElement('div');
        previewDiv.className = 'question-preview';
        const renderPreview = () => {
            previewDiv.innerHTML = marked.parse(questionInput.value);
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(previewDiv, { delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}] });
            }
        };
        questionInput.addEventListener('input', renderPreview);
        previewCell.appendChild(previewDiv);

        const answerCell = row.insertCell();
        const answerInput = document.createElement('textarea');
        answerInput.value = card.a;
        answerInput.addEventListener('input', () => autoResizeTextarea(answerInput));
        answerCell.appendChild(answerInput);
        
        const categoryCell = row.insertCell();
        const categoryInput = document.createElement('textarea');
        categoryInput.value = card.category;
        categoryInput.addEventListener('input', () => autoResizeTextarea(categoryInput));
        categoryCell.appendChild(categoryInput);
        
        const priorityCell = row.insertCell();
        const priorityControls = document.createElement('div');
        priorityControls.className = 'priority-controls';
        const minusBtn = document.createElement('button');
        minusBtn.textContent = '-';
        const priorityInput = document.createElement('input');
        minusBtn.onclick = () => { priorityInput.value = Math.max(1, parseInt(priorityInput.value) - 1); };
        priorityControls.appendChild(minusBtn);
        priorityInput.type = 'number';
        priorityInput.value = card.priority;
        priorityControls.appendChild(priorityInput);
        const plusBtn = document.createElement('button');
        plusBtn.textContent = '+';
        plusBtn.onclick = () => { priorityInput.value = parseInt(priorityInput.value) + 1; };
        priorityControls.appendChild(plusBtn);
        priorityCell.appendChild(priorityControls);
        
        const actionCell = row.insertCell();
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = () => deleteCard(card.id);
        actionCell.appendChild(deleteBtn);

        // Set initial sizes and previews
        setTimeout(() => {
          autoResizeTextarea(questionInput);
          autoResizeTextarea(answerInput);
          autoResizeTextarea(categoryInput);
          renderPreview();
        }, 0);
      });
      editorTable.innerHTML = '';
      editorTable.appendChild(table);
    }
    
    function addCard() {
      cards = getEditedCardsFromTable();
      cards.push({
        id: cards.length ? Math.max(...cards.map(c => c.id)) + 1 : 0,
        q: '',
        a: '',
        category: 'Uncategorized',
        priority: 1
      });
      renderEditorTable();
    }
    
    function sortCardsByCategory() {
        cards = getEditedCardsFromTable();
        cards.sort((a, b) => a.category.localeCompare(b.category));
        renderEditorTable();
    }

    function deleteCard(idToDelete) {
        cards = getEditedCardsFromTable();
        cards = cards.filter(card => card.id !== idToDelete);
        renderEditorTable();
    }

    function saveAndDownloadEditedCSV() {
        cards = getEditedCardsFromTable();
        downloadCSV(cards);
        prepareDeck();
        showPanel(mainPanel);
    }

    // Event listeners
    fileInput.addEventListener('change', () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) { meta.textContent = 'Choose a CSV file first.'; return; }
      const reader = new FileReader();
      reader.onload = (e) => loadFromText(e.target.result, f.name);
      reader.readAsText(f);
    });

    startBtn.addEventListener('click', () => {
      if (!unused.length) return;
      // Reset quiz state before starting
      roundCorrect = 0;
      roundAttempts = 0;
      incorrectLog = [];
      resetEndConfirmation();
      if (summaryEl) summaryEl.style.display = 'none';
      if (emptyMsg) emptyMsg.style.display = 'none';
      showPanel(quizPanel);
      nextCard();
      answerEl.focus();
    });

    priorityQuizBtn.addEventListener('click', () => {
      if (!cards.length) return;

      const n = parseInt(numCardsInput.value, 10);
      if (isNaN(n) || n <= 0) {
        meta.textContent = "Please enter a valid number of cards for the priority quiz.";
        return;
      }
      
      // Reset quiz state before starting
      roundCorrect = 0;
      roundAttempts = 0;
      incorrectLog = [];
      resetEndConfirmation();
      if (summaryEl) summaryEl.style.display = 'none';
      if (emptyMsg) emptyMsg.style.display = 'none';

      // Create a deck with the top N priority cards
      const topNCards = [...cards]
        .sort((a, b) => b.priority - a.priority)
        .slice(0, n);

      unused = topNCards;
      
      // Start the quiz
      showPanel(quizPanel);
      nextCard();
      answerEl.focus();
    });
    
    editCsvBtn.addEventListener('click', () => {
        renderEditorTable();
        showPanel(editorPanel);
    });
    
    addCardBtn.addEventListener('click', addCard);
    sortCategoryBtn.addEventListener('click', sortCardsByCategory);
    saveAndDownloadBtn.addEventListener('click', saveAndDownloadEditedCSV);
    cancelEditBtn.addEventListener('click', () => {
      cards = getEditedCardsFromTable();
      prepareDeck();
      renderCategoryFilters();
      showPanel(mainPanel);
    });

    toggleAllBtn.addEventListener('click', toggleAll);
    toggleNoneBtn.addEventListener('click', toggleNone);

    submitBtn.addEventListener('click', onSubmit);
    skipBtn.addEventListener('click', nextCard);
    editQuestionBtn.addEventListener('click', () => {
      if (!current) return;
      editFields.style.display = 'flex';
      editQuestionEl.value = current.q;
      editAnswerEl.value = current.a;
      editQuestionEl.focus();
      // Render initial preview for the edit view
      editQuestionPreview.innerHTML = marked.parse(editQuestionEl.value);
      if (typeof renderMathInElement !== 'undefined') {
        renderMathInElement(editQuestionPreview, { delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}] });
      }
      if (submitBtn) submitBtn.style.display = 'none';
      if (skipBtn) skipBtn.style.display = 'none';
      if (editQuestionBtn) editQuestionBtn.style.display = 'none';
    });
    // Live preview for the edit question textarea
    editQuestionEl.addEventListener('input', () => {
        editQuestionPreview.innerHTML = marked.parse(editQuestionEl.value);
        if (typeof renderMathInElement !== 'undefined') {
            renderMathInElement(editQuestionPreview, { delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}] });
        }
    });
    updateCardBtn.addEventListener('click', () => {
      if (!current) return;
      current.q = editQuestionEl.value;
      current.a = editAnswerEl.value;
      showCard(current);
      answerEl.focus();
      editFields.style.display = 'none';
      if (submitBtn) submitBtn.style.display = '';
      if (skipBtn) skipBtn.style.display = '';
      if (editQuestionBtn) editQuestionBtn.style.display = '';
    });
    cancelEditBtnQuiz.addEventListener('click', () => {
      showCard(current);
      answerEl.focus();
      editFields.style.display = 'none';
      if (submitBtn) submitBtn.style.display = '';
      if (skipBtn) skipBtn.style.display = '';
      if (editQuestionBtn) editQuestionBtn.style.display = '';
    });
    answerEl.addEventListener('keydown', (e) => {
      // Shift + Enter -> End quiz early & show summary
      if (e.key === 'Enter' && e.shiftKey) {
        e.preventDefault();
        if (endQuizConfirmation) {
          resetEndConfirmation();
          if (questionEl) questionEl.textContent = '';
          if (feedbackEl) feedbackEl.textContent = '';
          endOfRound();
        } else {
          endQuizConfirmation = true;
          endQuizConfirmEl.textContent = 'Are you sure? Press Shift + Enter again to end the quiz.';
          endQuizConfirmEl.style.display = 'block';
        }
        return;
      }

      // If we are in a confirmation state and another key is pressed, cancel it.
      if (endQuizConfirmation && e.key !== 'Shift') {
          resetEndConfirmation();
      }

      // Ctrl/Cmd + Enter -> Skip
      if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); nextCard(); return; }
      // Enter -> Check
      if (e.key === 'Enter') { e.preventDefault(); onSubmit(); }
    });
  </script>
</body>
</html>
